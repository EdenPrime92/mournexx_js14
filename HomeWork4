//Confirms

const questions = [
confirm('Вы любите котиков?'),
confirm('Вы хотели бы сейчас скушать вкуснейшую шаурму?'),
confirm('Вы хотели бы себе купить лютейшую снайперскую винтовку CheyTac M200 "Intervention" ?')
]//Литеральный(декларативный) синтаксис массива
console.log(questions)// в массив попадает 3 элемента с значениями true or false


//Prompts

const arr = []// создаем пустой массив
arr[0] = prompt('Вы любите котиков?')//добавляем 1й элемент массива
arr[1] = prompt('Вы хотели бы сейчас скушать вкуснейшую шаурму?')//добаляем 2й элемент массива
arr[2] = prompt('Вы хотели бы себе купить лютейшую снайперскую винтовку CheyTac M200 "Intervention" ?')// добавляем 3й элемент массива
console.log(arr[0])//обращение к элементами массива
console.log(arr[1])
console.log(arr[2])



//Item access

{
const arr = ['Котики', 'Шаурменька', 'ЛютаяСнайперскаяВинтовкаCheyTacM200Intervention']// Создаю массив
const indexOfArr = prompt('Введите индекс  массива (от 0 до 2)')// объявляю константу под индекс массива, которая в себе содержит введёное пользователем значение от 0 до 2
alert(arr[indexOfArr])//подставляю введёное пользователем значение как индекс массива и вывожу результат на экран через алерт
}



//Item change

{
const arr = ['Котики', 'Шаурменька', 'ЛютаяСнайперскаяВинтовкаCheyTacM200Intervention']
const indexOfArr = prompt('Введите индекс массива (от 0 до 2)')// объявляю константу под индекс массива, которая в себе содержит введёное юзером значение
let valueForIndex = prompt('Введите любой текст или любое число')// обьявляю константу под значение, которая в себе будет содержать то, что введёт юзер
arr[indexOfArr] = valueForIndex//Присваиваю индексу содержимое
alert(arr)
}



//Multiply table

const multiplyTable = [
[0, 0, 0, 0, 0],//тут нули, потому-что в первая позиция массива считается как 0(в ДЖиЕс считают с 0), следовательно 0 позиция массива умноженная на любой индекс будет равна 0
[0, 1, 2, 3, 4],// тут уже массив имеет 1 позицию, следовательно, умножаем на индексы по очереди и получаем следующее: 1х0 = 0, 1х1=1, 1х2=2, 1х3=3, 1х4=4
[0, 2, 4, 6, 8],//Массив имеет 2 позицию, следовательно, мы будем иметь : 2х0=0, 2х1=4, 2х2=4, 2х3=6, 2х4=8
[0, 3, 6, 9, 12],//Массив на 3 позиции и получается: 3х0=0, 3х1=3, 3х2=6, 3х3=9, 3х4=12
[0, 4, 8, 12, 16]//массив на 4 позиции и получается: 4х0=0, 4х1=4, 4х2=8, 4х3=12, 4х4=16
  ]



//Multiply table slice
{
const multiplyTable = [
[0, 0, 0, 0, 0],
[0, 1, 2, 3, 4],
[0, 2, 4, 6, 8],
[0, 3, 6, 9, 12],
[0, 4, 8, 12, 16]
]
let newMultiplyTable = multiplyTable.slice(1) // удаляем первый массив, в котором полно нулей
newMultiplyTable = multiplyTable.slice(1).map(row => row.slice(1))// с помощью метода map, перебираю все массивы и слайсом убираю первый элемент в каждом массиве
console.log(newMultiplyTable)
}



//IndexOf Word

const userText = prompt('Введите рядок из нескольких слов:')
const word = prompt('Укажите слово, которое необходимо найти:')
const words = userText.split(' ')// создаем массив слов, в котором разделяем слова пробелом, с помощью сплита
const wordIndex = words.indexOf(word)//метод IndexOf помогает найти индекс слова в массиве words. Если такое слово найдено, то значение WordIndex, будет индекс этого слова. Если нет, то значение будет -1
if (wordIndex !== -1) {//При условии, что слово найдено,  выводится алерт, сообщающий, что слово находится на соответствующей индексу позиции, если нет, выводится алерт, сообщающий что такого слова нет
const position = wordIndex + 1
alert(`Слово "${word}" находится на  ${position} позиции в строке.`)// угловые кавычки(`) нужны, что-бы ${word} находящееся считывалось корректно
} else {
alert(`Слово "${word}" не найдено в строке.`)
}


//Reverse

{
let arr1 = [];
for (let i = 0; i < 5; i++) {//запускаю цикл, в котором с помощью интерации, propmpt и push добавляем новые элементы в массив
  let element = prompt("Введите элемент:")
  arr1.push(element)
}
let arr2 = []//Создаю новый массив
while (arr1.length > 0) {//запускаю цикл , который будет работать, пока длина первого массива будет больше 0
  arr2.push(arr1.pop())//удаляю последний элемент первого массива и сразу же добавляю его во второй массив
}
console.log("Массив с обратным порядком элементов:", arr2)
}


//Reverse 2

let arr1 = []//прошлое задание
for (var i = 0; i < 5; i++) {
var element = prompt("Введите элемент:")
arr1.push(element)
}
let arr2 = []
while (arr1.length > 0) {
arr2.push(arr1.pop())
}


while (arr2.length > 0) {//запускаю цикл, который будет работать, пока длина массива arr2 будет больше 0
arr1.unshift(arr2.shift())//с помощью shift удаляю первый элемент массива arr2, потом с помощью unshift добавляю в массив arr1 удалённый элемент(короче говоря, обращаю порядок элементов)
}
console.log("Массив arr1:", arr1)


//Сору

{const multiplyTable = [
  [0, 0, 0, 0, 0],
  [0, 1, 2, 3, 4],
  [0, 2, 4, 6, 8],
  [0, 3, 6, 9, 12],
  [0, 4, 8, 12, 16]
]
const copiedTable = multiplyTable.slice()//создаю новый массив copiedTable из multiplyTable, используя slice(Делаю неглубокую копию. Любые изменения подмассивов будут отображаться и в основном и в копированном массивах)
console.log(copiedTable)
}



//Deep Copy

{
const multiplyTable = [
[0, 0, 0, 0, 0],
[0, 1, 2, 3, 4],
[0, 2, 4, 6, 8],
[0, 3, 6, 9, 12],
[0, 4, 8, 12, 16]
]
const copiedTable = []//создаю новый массив для копирования
for (let i = 0; i < multiplyTable.length; i++)//Цикл, при котором происходит итерация через рядки массива multiplyTable
{
copiedTable[i] = []//Создаю новый пустой массив copiedTable[i] при каждом шаге интерации внешнего цикла for
//(необходимо для того, что бы рядки в copiedTable не зависили от рядков в multiplyTable. Если этого не сделать, то любые изменения в copiedTable будут применены и к multiplyTable)
for (let j = 0; j < multiplyTable[i].length; j++)//Цикл, в котором происходит итерация через элементы вложенного массива
{
copiedTable[i][j] = multiplyTable[i][j]//копирую каждый элемент массива.(Присваиваю значение каждого элемента в массиве multiplyTable, соответствующему элементу массива copiedTable, при каждом шаге итерации)
}
}
console.log(copiedTable)
}



//Array equals

{
const arr1 = [1, 2, 3]
const arr2 = arr1
console.log(arr1 === arr2)
}



//Flat

{
const multiplyTable = [
  [0, 0, 0, 0, 0],
  [0, 1, 2, 3, 4],
  [0, 2, 4, 6, 8],
  [0, 3, 6, 9, 12],
  [0, 4, 8, 12, 16]
]
const flatArr = [].concat(...multiplyTable)//Используя спред, я превращаю элементы в массиве multiplyTable на отдельные значения, которые становятся аргументами для метода concat, который объединяет все отдельные значения в один массив
console.log(flatArr.length)
console.log(flatArr)
}


//Destruct

const text = prompt('Введите любое длинное слово(например, СИНХРОФАЗОТРОН)')
const [firstLetter, , , ,fifthLetter, , , ,ninthLetter] = text
alert(`Первая буква: ${firstLetter}`)
alert(`Пятая буква: ${fifthLetter}`)
alert(`Девятая буква: ${ninthLetter}`)



//Destruct default

{
const text = prompt("Введите любое слово:");
const [, secondLetter = '!', , fourthLetter = '!', fifthLetter = '!'] = text
alert(`Вторая буква: ${secondLetter}`)
alert(`Четвертая буква: ${fourthLetter}`)
alert(`Пятая буква: ${fifthLetter}`)
}



//Multiply table rest

{
const multiplyTable = [
[0, 0, 0, 0, 0],
[0, 1, 2, 3, 4],
[0, 2, 4, 6, 8],
[0, 3, 6, 9, 12],
[0, 4, 8, 12, 16]
]
const [, ...otherArrays] = multiplyTable//деструктуризация с оператором rest, собирает оставшиеся элементы массива в новый массив
//в данном случае, [, ...otherArrays] rest добавляет все оставшиеся элементы после первой запятой, то есть, будут добавлены все элементы массива кроме [0, 0, 0, 0, 0]
const flatArray = otherArrays.flat()//сливаю вложенные массивы в один массив. С помощью метода flat я превращаю массив с вложенными массивами(как элементами одного массива) в одномерный массив 
const zerolessArray = flatArray.filter(num => num !== 0) // метод filter с условием, что любое число не должно быть равно нулю, позволяет отфильтровать всё, что равно 0 и оставить в массиве всё, что не равно нулю
console.log(zerolessArray)
}



//for Alert

const names = ["John", "Paul", "George", "Ringo"]
for (const name of names) {//конструкция цикла for...of , позволяет присваивать переменной name значение элементов массива names по очереди, с помощью итерации.
alert(name)
}



//For Select Option

const currencies = ["USD", "EUR", "GBP", "UAH"]
let str = "<select>"//обьявляю переменную str и добавляю в неё открывающий тег select 
for (const currency of currencies) {//использую цикл for...of, что-бы пройтись по каждому элеменету массива и выполнить с ними действие, указанное в следующей строке
str += `<option>${currency}</option>`//"обволакиваю" каждый элемент массива в тег option, что-бы сработал html код и потом добавляю его к строке str
}
str += "</select>"//добавляю закрывающий тег </select> к строке str 
document.write(str)//вывожу список в окно браузера



//For Table Vertical

{
const names = ["John", "Paul", "George", "Ringo"]
let str = "<table>"//добавляю открывающий тег <table> в строку. Тег table определяет контейнер для организации данных в виде рядков и столбиков
for (const name of names) {//инициирую цикл for...of
str += "<tr>"//добавляю в строку открывающий тег <tr>(тег представляет собой рядок или строку в таблице)
str += `<td>${name}</td>`//добавляю открывающий и закрываюший тег td(внутри тега <tr> должен быть тег <td>), между которыми добавляю имя
str += "</tr>"//добавляю закрывающий тег </tr>
}
str += "</table>"//добавляю закрывающий тег table к строке
document.write(str)
}


//For table horizontal

{
const names = ["John", "Paul", "George", "Ringo"]
let str = "<table>"
str += "<tr>"
for (const name of names) {// в цикле перебираются по очереди элементы массива.
  str += "<td>" + name + "</td>"//при каждой итерации цикла создаётся строка, содержащая открывающий тег, имя и закрывающий тег. В итоге мы получим горизонтальное расположение имен в таблице
}
str += "</tr>"
str += "</table>"
document.write(str)
}



//For Table Letters

{
const currencies = ["USD", "EUR", "GBP", "UAH"]
let str = "<table style='border-collapse: collapse;'>"
const cellStyle = "border: 2mm solid black; padding: 5px;"
for (const currency of currencies) {
str += "<tr>"
for (const letter of currency) {
str += `<td style='${cellStyle}'>${letter}</td>`
}
str += "</tr>"
}
str += "</table>"
document.write(str)
}


//For Multiply Table

{
const multiplyTable = [
[0, 0, 0, 0, 0],
[0, 1, 2, 3, 4],
[0, 2, 4, 6, 8],
[0, 3, 6, 9, 12],
[0, 4, 8, 12, 16]
]
document.write("<table>")
for (const row of multiplyTable) {
document.write("<tr>")
for (const number of row) {
const rowStyle = multiplyTable.indexOf(row) % 2 === 0 ? "background-color: green;" : "background-color: red;";//с помощью остатка от деления, определяю, какой рядок парный и не парный и присваиваю им стиль
document.write(`<td style="${rowStyle}">${number}</td>`)
}
document.write("</tr>")
}
document.write("</table>")
}

//Function Capitalize

const capitalize = str => 
{
let result = str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()
return result
}
console.log(capitalize("cANBerRa"))



//Map Capitalize

{
const userText = prompt("Введите любой текст: ")
const words = userText.split(" ")
const capitalize = words.map(word => word.charAt(0).toUpperCase() + word.slice(1))
const result = capitalize.join(" ")
console.log("Результат:", result)
}


//Filter Lexics

{
const userText = prompt("Введіть рядок: ")
const forbiddenWords = ["хуй", "бля", "путин"]
const words = userText.split(" ")
const filteredWords = words.filter(word => !forbiddenWords.includes(word))
const result = filteredWords.join(" ")
console.log("Результат:", result)
}


//BEEP Lexics

{
const userText = prompt("Введіть рядок: ")
const forbiddenWords = ["бляха", "муха", "путин"]
const words = userText.split(" ")
const filteredWords = words.map(word => forbiddenWords.includes(word.toLowerCase()) ? "BEEP" : word)//добавил toLowerCase, что-бы в случае ввода слова заглавными буквами, они автоматически становились маленькими
const result = filteredWords.join(" ")
console.log("Результат:", result)
}


//Reduce HTML

{
const currencies = ["USD", "EUR", "GBP", "UAH"]
const selectOptions = currencies.reduce((a, currency) => a + `<option>${currency}</option>`, "")
//Во время выполнения reduce, при каждой итерации, функция обратного вызова берет текущий элемент currency и добавляет его к a. Результат этой операции становится новым значением а при каждой итерации.
const str = "<select>" + selectOptions + "</select>"//добавляем открывающий и закрывающий теги в строку str
document.write(str)
}


//For Brackets Hell Check

const userBrackets = prompt("Введите рядок с скобками (), {}, []: ")
const bracketsStack = [] // создаю пустой стек, для хранения скобок
let i = 0 // создаю счётчик для отслеживания позиции в строке
let errorFound = false // переменная errorFound помогает определить, были ли найдены ошибки при проверке парности скобок и выбрать соответствующее сообщение об ошибке или успехе
for (const bracket of userBrackets) {//запускаю цикл, что-бы перебирать каждый символ bracket в строке userBrackets
  if (bracket === '[' || bracket === '(' || bracket === '{') {//проверяю, является каждый символ в строке открывающей скобкой
    bracketsStack.push({ bracket, index: i })//если скобка является открывающей, она добавляется в стек, сохраняя информацию о себе(что конкретно за символ) и индекс позиции
  } else if (bracket === ']' || bracket === ')' || bracket === '}') {//проверяет, является ли символ закрывающей скобкой
    const lastBracket = bracketsStack.pop()//извлекают последнюю скобку из стека с помощью метода рор и сохраняет в переменную lastBracket
    //делается это для сравнения, соответствует ли закрывающая скобка последней открывающей скобке из lastBracket
    if (
      (bracket === ']' && lastBracket?.bracket !== '[') ||
      (bracket === ')' && lastBracket?.bracket !== '(') ||
      (bracket === '}' && lastBracket?.bracket !== '{')
    ) {//если нет соответствия между открывающей и закрывающей скобкой, то будет выведена ошибка, сообщающая на какой позиции есть несоответствие
      console.log(`Ошибка. Непарные скобки на позиции ${i}`)//сообщает о первой непарной скобке
      errorFound = true
      break//прерывает цикл
    }
  }
  i++//переключается на следующую позицию, после итерации каждого символда
}
if (!errorFound) {//Проверяет, были ли обнаружены ошибки или нет 
if (bracketsStack.length === 0) {//если ошибок нет, проверяет пустой ли стек. Если стек пустой, выводит сообщение, что все скобки парные
console.log('Все скобки парные')
} else {//если стек не пустой, выводит сообщение на какой позиции скобка не парная
console.log(`Ошибка. Непарная скобка на позиции ${bracketsStack[0].index}`)
}
}

